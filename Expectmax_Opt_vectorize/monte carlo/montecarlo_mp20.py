# -*- coding: utf-8 -*-
"""Copy of montecarlo multiprocessing

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SV7IbRFh7JxEbjC18zuzDqtI-375CiYs
"""

import random
import numpy as np
import time
import multiprocessing

singleScore=[0,0,4,16,48,128,320,768,1792,4096,9216,20480,45056,98304,212992,458752,983040]
moveDict=np.load('move.npy')

def add_two(mat):
    indexs=np.argwhere(mat==0)
    index=np.random.randint(0,len(indexs))
    mat[tuple(indexs[index])] = 1
    return mat

def game_state(mat):
    return 'not over' if np.any(mat == 0) or np.any(mat[:, 0:-1]==mat[:, 1:]) or np.any(mat[0:-1, :]==mat[1:, :]) else 'lose'

def move(list):
    return moveDict[list[0],list[1],list[2],list[3],:]

def lookup(x):
    return singleScore[x]

lookup = np.vectorize(lookup)

def getScore(matrix):
    return np.sum(lookup(matrix))

def isSame(grid1,grid2):
    return np.all(grid1==grid2)

def moveGrid(grid,i):
    # new=np.zeros((4,4),dtype=np.int)
    new = None
    if i==0:
        # move up
        grid=np.transpose(grid)
        new = np.stack([move(grid[row,:]) for row in range(4)], axis = 0).astype(int).T
    elif i==1:
        # move left
        new = np.stack([move(grid[row,:]) for row in range(4)], axis = 0).astype(int)
    elif i==2:
        # move down
        grid=np.transpose(grid)
        new = np.stack([np.flip(move(np.flip(grid[row,:]))) for row in range(4)], axis = 0).astype(int).T
    elif i==3:
        # move right
        new = np.stack([np.flip(move(np.flip(grid[row,:]))) for row in range(4)], axis = 0).astype(int)
    return new

def getMove(grid, numBackgroundRuns):
    queue = multiprocessing.Queue()
    processes = []
    maxScore = 0
    for i in range(4):
        nextGrid = moveGrid(grid, i)
        if not isSame(grid, nextGrid):
            p = multiprocessing.Process(target=randomPolicyUntilGameOver, args=(nextGrid, numBackgroundRuns, queue))
            p.start()
            processes.append(p)

    for p in processes:
        p.join()

    while not queue.empty():
        score, grid = queue.get()
        if score > maxScore:
            maxScore = score
            matrix = grid
    return matrix


def randomPolicyUntilGameOver(grid, numBackgroundRuns, queue):
    score = 0
    for i in range(numBackgroundRuns):
        curGrid = grid.copy()
        while True:
            curGrid = add_two(curGrid)
            board_list = randomMove(curGrid)
            if not board_list:
                break
            curGrid = random.choice(board_list)
        score += getScore(curGrid)
    queue.put((score, grid))
    return score, grid


def randomMove(grid):
    board_list = []
    for i in range(4):
        newGrid = moveGrid(grid, i)
        if not isSame(grid, newGrid):
            board_list.append(newGrid)
    return board_list

ITERATION=100
NUM_BACKGROUND_RUNS=20
stat=[]

def main():
    f= open("montecarlo.txt","w+")
    for iteration in range(ITERATION):
        print("Iteration: "+str(iteration+1))
        start=time.time()
        step=0
        matrix=np.zeros((4,4),dtype=np.int)
        matrix = add_two(matrix)
        while True:
            matrix = add_two(matrix)
            if game_state(matrix)=='lose':
                break

            matrix=getMove(matrix, NUM_BACKGROUND_RUNS)
            step+=1

        f.write("Step %d, max %d, Score %d, \r\n" % (step, 2**np.max(matrix), getScore(matrix)))
        f.flush()
        print('Time= '+str(time.time()-start))

if __name__ == '__main__':
    main()